---
title: "빅오(Big-Oh)와 시간복잡도(Time-Complexity)"
date: 2020-05-11T14:46:42+09:00
categories: ["Data Structure"]
tags: []
cover: "https://postfiles.pstatic.net/MjAxOTEyMjVfMjMx/MDAxNTc3MjQ3NzIzNjEw.PoxRjY8gBkBphRIPe1GtQg5Xsn5mNq6zE5O2YFtIuOgg.4if3jNQOwxSNJeuvMiFzw66V8mqYvbTXrx5SnyWgEQ8g.PNG.sjc02183/image.png?type=w773"
---

한정되어 있는 자원에서 그 자원을 항상 효율적으로 사용해야 할 때, 어떤 알고리즘이 좋은 알고리즘일까? 간단하게 두 가지 기준을 두어보자.

1. 빠르게 실행되고(실행시간)

2. 자리를 적게 차지하는(기억장소) 알고리즘

을 좋은 알고리즘이라고 생각할 수 있다. 실제로 데이터구조와 알고리즘에 대한 공부는 이 분석 방법에 대한 배경지식 없이는 무의미하다고 할 수 있다. 실행시간이 빠르더라도 기억장소 요구량이 크거나, 기억장소 요구량은 많지 않지만 실행시간이 느리다면 좋은 프로그램이라 할 수 없다.

하지만 기억장치 제조기술이 눈부시게 발전하면서 기억장치 제조기술 발전과 기억장치 값 하락이 맞물려 기억장소 활용법에 대해서는 어느정도 관대해지는 경향이 있어 최근의 알고리즘은 실행시간을 줄이는 것을 위주로 하고 있고, Dynamic Programming(다이나믹 프로그래밍)같이 공간을 마구 사용해서 시간복잡도를 줄이는 변태적인 방법까지 사용하고 있다.

그렇다면 컴퓨터의 실행시간은 어떻게 정의할까? 시간으로? 컴퓨터의 성능에 따라 달라지는 시간은? 그 복잡한 과정을 해결하기 위해 과학자들은 놀라운 모델을 창조해냈다.

​

임의접근기계 모델(Random Access Machine Model)

​

복잡한 컴퓨터에서 일어나는 복잡한 일들을 모두 실행시간으로 포함시키는 것은 너무나도 복잡하고 인간에게 귀찮은 일이기 때문에, 컴퓨터 공학자들은 이를 추상화시키고 간단화하였다. 임의접근기계라 불리는 간단한 컴퓨터는 하나의 중앙처리장치(CPU)와 무제한의 메모리로 구성되어있다고 가정한다. 어떠한 셀의 처리도 원시 작업시간, 1의 시간이 들어간다고 가정한다.

-> 문제가 너무 간단해졌다! 원시작업시간은 

1. 산술식/논리식의 평가(EXP)

2. 변수에 특정 값을 치환(ASS)

3. 배열에 있는 원소의 접근(IND)

4. Method 호출(CAL)

5. Method 반환(RET)

등으로 정의되며 이 모든 실행은 1의 시간이 들어간다.

​

문제 1. 2차 for문을 10번씩 돌리면 몇의 시간이 걸리게 될까? -> 10^2 = 100의 시간이 걸린다.